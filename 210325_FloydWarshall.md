## ✅ 최단 경로(Shortest Path)

### 1. brute-force 접근 방법

> 한 정점에서 다른 정점으로의 모든 경로를 구한 뒤, 그들 중에서 최단 경로를 찾는다.   
그래프가 n개의 정점을 가지고 있고, 완전 그래프라고 가정한다.   
한 정점 i에서 어떤 정점 j로 가는 경로들을 모두 모아보면 그 경로들 중에서 나머지 모든 정점을 한번씩은 꼭 거쳐서 가는 경로들도 포함되어 있는데, 그 경로들의 수만 우선 계산해보자.   
i에서 출발하여 처음에 도착할 수 있는 정점의 가지 수는 n-1개 이고, 그 중에 하나를 선택하면 그 다음에 도착할 수 있는 정점의 가지 수는 n-3개 이다.   
이렇게 계속하여 계산해보면 총 경로의 개수는 (n-2)(n-3)...1 = (n-2)!이 된다.   
이 경로의 개수만 보아도 지수보다 훨씬 크므로, 이 알고리즘은 절대적으로 비효율적이다!
 
### 2. DP 접근 방법
- 각 점을 시작점으로 정하여 다익스트라(Daijkstra)의 최단 경로 알고리즘을 수행한다.
- 시간 복잡도는 인접행렬을 사용하면 O(n^3)이다. (n: 정점의 수)
- 플로이드 알고리즘의 시간 복잡도도 마찬가지로 O(n^3)이지만, 알고리즘이 매우 간단하다.

## ✅ Floyd-Warshall 알고리즘
```
D[i][j] = 정점 i에서 정점 j로의 최소비용
AllPairShortest(D[][])
    FOR k in 1 -> n
        FOR i in 1 -> n       (단, i != k)
            FOR j in 1 -> n   (단, j != k, j != i)
                D[i][j] <- min(D[i][k] + D[k][j], D[i][j])
```
- Line 1의 for 루프는 k가 1에서 n까지 변하는데, 이는 경유 가능한 정점을 1부터 n까지 확장하는 것
- Line 2~3: 점들의 각 쌍을 하나씩 고려하기 위한 루프
- Line 4: 각 정점의 쌍 i-j에 대해 i에서 j까지의 거리가 k를 포함하여 경유하는 경로의 거리, 즉 D[i][k] + D[k][j]와 정점 {1, 2, ..., (k-1)}만을 경유 가능한 점들로 고려하여 계산된 최단 경로의 거리 D[i][j]가 짧은지를 결정하여 D[i][j]를 갱신한다. 
